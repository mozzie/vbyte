\chapter{Introduction}
Enormous datasets are a common case in today's applications. Compressing the datasets is beneficial, because they 
naturally decrease memory requirements but also are faster when compressed data is read from disk \citep{Zob95}.

One of the leading methods of data compression is variable-length coding \citep{Sal99}, where frequent sequences of data
are represented with shorter codewords. Because the sequences of data have different lenghts when compressed, it is 
not trivial to determine the exact location of a certain element. If this is required, the usual data compression algorithms are
inefficient. Fortunately this is not a requirement compression algorithms usually need to fulfill. 

However, random access of compressed data is needed in compressed data structures. In most compression methods, the only way 
to this is to decompress data from the beginning. An integer compressing method with fast random access is explained later and compared
existing state-of-the-art methods.

\chapter{Variable-byte encoding}

Variable-byte (VB) encoding \citep{Wil99} is a method of compressing integers via omitting leading zero bits. In normal data sets, it loses in 
compression performance to generic algorithms like Huffman encoding or Lempel-Ziv encoding, but in comparison it's faster to decode \citep{Bri09} 
and allows constant time random access. This is later explained in (TODO: link to later chapter). 

A good data set for VB encoding is a list of mostly small numbers with a need to support larger ones. A search engine may use an inverted index of 
words in documents. For each word, a list of document IDs where the word appears is stored. It may also store locations of the word in document for 
advanced search purposes. Usually these lists are preprocessed and stored as gaps, storing the difference to previous number instead of the actual 
number \citep{Man08}. Common words have a lot of entries in these lists, but because of gap storing the numbers are small. In contrast, rare words 
have only a few entries but the numbers stored are larger. These lists are excellent data sets for VB encoding. 

VB encoding splits each integer into blocks of $b$ bits and adds a continuation bit to the block to form chunks of length $1+b$. The extra bit is set to 1 only
on the block containing the least significant bits of the integer. This information is used in decoding to signal if next chunk continues the current 
integer. For example, let's assume $b = 4$ and let $n = 42$ be a 16 bit unsigned integer. The standard 8-bit representation of $n$ is 
\texttt{00000000 00101000}. When split to blocks of $b$ bits, it becomes \texttt{0000 0000 0010 1000}. Empty blocks are omitted and continuation bits 
are added to the remaining blocks. The result is \texttt{00010 11000}, which is the compressed data.

\medskip
\noindent\begin{minipage}{.5\textwidth}
\begin{algorithmic}
\Function{VBEncodeNumber}{$n$}
\State $bytes\gets $ list
\While{true}
\State $bytes$.prepend($n \bmod 128$)
\If{$n < 128$} \State break \EndIf
\State $n\gets n$ div $128$
\EndWhile
\State $bytes$.last() += $128$
\State \textbf{return} bytes
\EndFunction
\captionof{figure}{VByte encoding} \label{vbyte_enc}
\end{algorithmic}
\end{minipage}%
\begin{minipage}{.5\textwidth}
\begin{algorithmic}
\Function{VBEncode}{$numbers$}
\State $bytestream\gets $ list
\ForEach {$n \in numbers$}
\State $bytes \gets$ VBEncodeNumber($n$)
\State $bytestream$.extend($bytes$)
\EndFor
\State \textbf{return} bytestream
\EndFunction
\end{algorithmic}
\end{minipage}
\medskip 

Decoding is essentially just reversing the encoding steps: chunks are read until a chunk with 1 as continuation bit is found. Continuation bits 
are removed from all the chunks and the blocks are concatenated to form the original number. As in the previous example, $b = 4$, encoded message 
is \texttt{00010 11000} and $n = 0$. Block from the first chunk is extracted and added to $n$, making $n = $\texttt{10}. A bitwise shift to left 
equal to $b$ is applied to $n$, changing $n = $\texttt{100000}. Then the block is extracted from the next chunk. This block is added  $n$, making 
$n = 42$. Because the previous continuous bit was 1, decoding this number has finished. An example implementation of encode and decode with block 
length of 7 is shown in Figure~\ref{vbyte_enc} and Figure~\ref{vbyte_dec}.

\begin{figure}[ht]
\begin{algorithmic}
\Function{VBDecode}{$bytestream$}
\State $numbers\gets $ list
\State $n\gets 0$
\ForEach {$b \in bytestream$}
\If{$b < 128$}
\State $n\gets 128\times n $ + $b$
\Else
\State $n\gets 128\times n $ + $b$ - $128$
\State $numbers$.append($n$)
\State $n\gets 0$
\EndIf
\EndFor
\State \textbf{return} numbers
\EndFunction
\end{algorithmic}
\caption{VByte decoding} \label{vbyte_dec}
\end{figure}

Small lengths of $c$ can yield better compression rate at the cost of more bit manipulation, while longer chunks need less bit manipulation and 
offer less effective compression. Generally block length of 7 has been used because it gives a good average and handling chunks as bytes is 
convenient \citep{Man08}.

VB encoding is a well known compression algorithm. It's origins date back to 1980's and the famous MIDI music file format. It stored some of the numbers
in a "variable-length quantity" form, which was a 7-bit block VB structure \citep{Mid96}. Similar data types have existed for example in Apache Lucene 
(as vInt) and IBM DB2 database (as Variable Byte). Later, VB encoding was found efficient in compressing integer lists. It was first used to compress
lists of word locations in documents \citep{Sch02}. It yielded excellent records, and since then many different approaches have been introduced. 



history and current implementations etc here
 - mainitse IR book, Lem15, Pla18

TODO: a chapter about existing work



\chapter{Directly addressable codes?}
Rank and select are two functions that work on bit arrays. Rank(i) gives the sum of 1 bits from the beginning of the bit array and select(i) gives
the index of ith 1 bit in the bit array. Both functions work in constant time (citation?) and they require only a few percents of extra space over
the data. The extra bits $c$ added by variable-byte encoding conveniently create a bit array, where 1's represent the endings of numbers. An effective
version of random access has already been introduced \citep{Bri09}. 

Random access with select query is also possible.  By separating the $c$ bit array and $b$ block array, $b$ contains variable-byte integers 
in readable form. Another upside is that functions next(i) and previous(i) are conveniently available. Rank implementation has 

- explain how random access is good 

\chapter{Previous Work}
bl

\chapter{Algorithm}

 - modifications to basic implementation
 
\chapter{Results}
 - comparison to basic implementation + Bri09
\begin{table}
\centering
\caption{Results with 100k entries (in milliseconds).\label{table:results1}}
\begin{tabular}{l||l c c c c r} 
Experiment & 128 & 256 & 32768 & 65536 & $2^{24}$ & $2^{32} -1$\\ 
\hline \hline 
$7bit VByte encoding$ & 34.97 & 49 & 53.04 & 52.18 & 53.08 & 76.21\\
$8bit VByte encoding$ & 33.57 & 32.47 & 42.96 & 43.11 & 46.15 & 65.14\\
$7bit VByte encoding with array$ & 33.39 & 46.85 & 51.24 & 49.03 & 48.93 & 66.84 \\
$8bit VByte encoding with array$ & 32.52 & 31.88 & 41.54 & 39.94 & 41.15 & 52.86 \\

\hline
%
\end{tabular}
\end{table}

\begin{table}
\centering
\caption{Results with 1M entries (in milliseconds).\label{table:results2}}
\begin{tabular}{l||l c c c c r} 
Experiment & 128 & 256 & 32768 & 65536 & $2^{24}$ & $2^{32} -1$ \\ 
\hline \hline 
$7bit VByte encoding$ & 38.17 & 55.09 & 64.38 & 65.36 & 68.08 & 159 \\
$8bit VByte encoding$ & 37.09 & 37.75 & 53.44 & 54.6 & 59.32 & 148.7\\
$7bit VByte encoding with array$ & 38.09 & 55.42 & 62.22 & 61.25 & 71.72 & 135.01\\
$8bit VByte encoding with array$ & 36.13 & 36.83 & 50.58 & 50.73 & 56.93 & 103.18\\

\hline
%
\end{tabular}
\end{table}

\chapter{Conclusion}
 - here

\chapter{Future work}
 - something to improve / research?


\section{Figures}
Figure gives an example how to add figures to the document. Remember always to cite the figure in the main text.


\section{Tables}

Table gives an example how to report experimental results. Remember always to cite the table in the main text. 


\chapter{From tex to pdf}

In Linux, run \texttt{pdflatex filename.tex} and \texttt{bibtex filename.tex} repeatedly until no more warnings are shown. This process can be automised using make-command.
 
\chapter{Conclusions\label{chapter:conclusions}}

It is good to conclude with a summary of findings. You can also use separate chapter for discussion and future work. These details you can negotiate with your supervisor.

