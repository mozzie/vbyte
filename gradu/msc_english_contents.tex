\chapter{Introduction}
Enormous datasets are a common case in today's applications. Compressing the datasets is beneficial, because they 
naturally decrease memory requirements but also are faster when compressed data is read from disk \citep{Zob95}.

One of the leading methods of data compression is variable-length coding \citep{Sal99}, where frequent sequences of data
are represented with shorter codewords. Because the sequences of data have different lenghts when compressed, it is 
not trivial to determine the exact location of a certain element. If this is required, the usual data compression algorithms are
inefficient. Fortunately this is not a requirement compression algorithms usually need to fulfill. 

However, random access of compressed data is needed in compressed data structures. In most compression methods, the only way 
to this is to decompress data from the beginning. An integer compressing method with fast random access is explained later and compared
existing state-of-the-art methods.

\chapter{Variable-byte encoding}

Variable-byte encoding \citep{Wil99} (VB) is a method of compressing integers via omitting leading zero bits. In normal data sets, it loses in 
compression performance to generic algorithms like Huffman encoding or Lempel-Ziv encoding, but in comparison it's faster to decode \citep{Bri09} 
and allows constant time random access (TODO: link to later chapters). A good data set for VB encoding is a list of mostly small numbers with a 
need to support larger ones. 

A search engine may use an inverted index of words in documents. For each word, a list of document IDs where the word appears is stored. 
It may also store locations of the word in document for advanced search purposes. Usually these lists are preprocessed and stored 
as gaps, storing the difference to previous number instead of the actual number \citep{Man08}. Common words have a lot of entries in these lists, 
but because of gap storing the numbers are small. In contrast, rare words have only a few entries but the numbers stored are larger. These lists 
are excellent data sets for VB. Apache Lucene has variable bytes as vInt and IBM DB2 has them as Variable Byte). 


TODO: a chapter about existing work
Usage of VB to compress inverted 
index lists was first experimented in \citep{Sch02}. (TODO: find better examples or find references to these)

VB splits each integer into blocks of $b$ bits and adds a continuation bit to the block to form chunks of length $1+b$. The extra bit is set to 1 only
on the block containing the least significant bits of the integer. This information is used in decoding to signal if next chunk continues the current 
integer. For example, let's assume $b = 4$ and let $n = 42$ be a 16 bit unsigned integer. The standard 8-bit representation of $n$ is 
\texttt{00000000 00101000}. When split to blocks of $b$ bits, it becomes \texttt{0000 0000 0010 1000}. Empty blocks are omitted and continuation bits 
are added to the remaining blocks. The result is \texttt{00010 11000}, which is the compressed data.

\medskip
\noindent\begin{minipage}{.5\textwidth}
\begin{algorithmic}
\Function{VBEncodeNumber}{$n$}
\State $bytes\gets $ list
\While{true}
\State $bytes$.prepend($n \bmod 128$)
\If{$n < 128$} \State break \EndIf
\State $n\gets n$ div $128$
\EndWhile
\State $bytes$.last() += $128$
\State \textbf{return} bytes
\EndFunction
\captionof{figure}{VByte encoding} \label{vbyte_enc}
\end{algorithmic}
\end{minipage}%
\begin{minipage}{.5\textwidth}
\begin{algorithmic}
\Function{VBEncode}{$numbers$}
\State $bytestream\gets $ list
\ForEach {$n \in numbers$}
\State $bytes \gets$ VBEncodeNumber($n$)
\State $bytestream$.extend($bytes$)
\EndFor
\State \textbf{return} bytestream
\EndFunction
\end{algorithmic}
\end{minipage}
\medskip 

Decoding is essentially just reversing the encoding steps: chunks are read until a chunk with 1 as continuation bit is found. Continuation bits 
are removed from all the chunks and the blocks are concatenated to form the original number. As in the previous example, $b = 4$, encoded message 
is \texttt{00010 11000} and $n = 0$. Block from the first chunk is extracted and added to $n$, making $n = $\texttt{10}. A bitwise shift to left 
equal to $b$ is applied to $n$, changing $n = $\texttt{100000}. Then the block is extracted from the next chunk. This block is added  $n$, making 
$n = 42$. Because the previous continuous bit was 1, decoding this number has finished. An example implementation of encode and decode with block 
length of 7 is shown in Figure~\ref{vbyte_enc} and Figure~\ref{vbyte_dec}.

Small lengths of $c$ can yield better compression rate at the cost of more bit manipulation, while longer chunks need less bit manipulation and 
offer less effective compression. Generally block length of 7 has been used because it gives a good average and handling chunks as bytes is 
convenient \citep{Man08}.


\begin{figure}[ht]
\begin{algorithmic}
\Function{VBDecode}{$bytestream$}
\State $numbers\gets $ list
\State $n\gets 0$
\ForEach {$b \in bytestream$}
\If{$b < 128$}
\State $n\gets 128\times n $ + $b$
\Else
\State $n\gets 128\times n $ + $b$ - $128$
\State $numbers$.append($n$)
\State $n\gets 0$
\EndIf
\EndFor
\State \textbf{return} numbers
\EndFunction
\end{algorithmic}
\caption{VByte decoding} \label{vbyte_dec}
\end{figure}


+description

\medskip
-motivation (see papers below)

\medskip
+pseudocode

\medskip
+a few examples (1)

\medskip
-a review of related work should include:

\medskip
---the text book from which the initial description I sent you comes from

\medskip
---First use for inverted index compression (at least that I'm aware of):

\medskip
https://dl.acm.org/doi/10.1145/564376.564416

\medskip
---More recent incarnations of vbyte (just mention them):

\medskip
https://arxiv.org/abs/1709.08990

\medskip
https://arxiv.org/abs/1503.07387

\medskip




\chapter{Directly addressable codes?}
Rank and select are two functions that work on bit arrays. Rank(i) gives the sum of 1 bits from the beginning of the bit array and select(i) gives
the index of ith 1 bit in the bit array. Both functions work in constant time (citation?) and they require only a few percents of extra space over
the data. The extra bits $c$ added by variable-byte encoding conveniently create a bit array, where 1's represent the endings of numbers. An effective
version of random access has already been introduced \citep{Bri09}. 

Random access with select query is also possible.  By separating the $c$ bit array and $b$ block array, $b$ contains variable-byte integers 
in readable form. Another upside is that functions next(i) and previous(i) are conveniently available. Rank implementation has 

- explain how random access is good 

\chapter{Previous Work}
bl

\chapter{Algorithm}

 - modifications to basic implementation
 
\chapter{Results}
 - comparison to basic implementation + Bri09
\begin{table}
\centering
\caption{Results with 100k entries (in milliseconds).\label{table:results1}}
\begin{tabular}{l||l c c c c r} 
Experiment & 128 & 256 & 32768 & 65536 & $2^{24}$ & $2^{32} -1$\\ 
\hline \hline 
$7bit VByte encoding$ & 34.97 & 49 & 53.04 & 52.18 & 53.08 & 76.21\\
$8bit VByte encoding$ & 33.57 & 32.47 & 42.96 & 43.11 & 46.15 & 65.14\\
$7bit VByte encoding with array$ & 33.39 & 46.85 & 51.24 & 49.03 & 48.93 & 66.84 \\
$8bit VByte encoding with array$ & 32.52 & 31.88 & 41.54 & 39.94 & 41.15 & 52.86 \\

\hline
%
\end{tabular}
\end{table}

\begin{table}
\centering
\caption{Results with 1M entries (in milliseconds).\label{table:results2}}
\begin{tabular}{l||l c c c c r} 
Experiment & 128 & 256 & 32768 & 65536 & $2^{24}$ & $2^{32} -1$ \\ 
\hline \hline 
$7bit VByte encoding$ & 38.17 & 55.09 & 64.38 & 65.36 & 68.08 & 159 \\
$8bit VByte encoding$ & 37.09 & 37.75 & 53.44 & 54.6 & 59.32 & 148.7\\
$7bit VByte encoding with array$ & 38.09 & 55.42 & 62.22 & 61.25 & 71.72 & 135.01\\
$8bit VByte encoding with array$ & 36.13 & 36.83 & 50.58 & 50.73 & 56.93 & 103.18\\

\hline
%
\end{tabular}
\end{table}

\chapter{Conclusion}
 - here

\chapter{Future work}
 - something to improve / research?


\section{Figures}
Figure gives an example how to add figures to the document. Remember always to cite the figure in the main text.


\section{Tables}

Table gives an example how to report experimental results. Remember always to cite the table in the main text. 


\chapter{From tex to pdf}

In Linux, run \texttt{pdflatex filename.tex} and \texttt{bibtex filename.tex} repeatedly until no more warnings are shown. This process can be automised using make-command.
 
\chapter{Conclusions\label{chapter:conclusions}}

It is good to conclude with a summary of findings. You can also use separate chapter for discussion and future work. These details you can negotiate with your supervisor.

